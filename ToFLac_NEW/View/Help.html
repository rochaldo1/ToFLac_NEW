<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Справка</title>
    <style>
        html, body {
            height: 100%;
            width: 100%;
            margin: 0px;
        }
        .nav {
            display: flex;
            justify-content: left;
            background-color: #555555;
        }

        .ul-nav {
            display: flex;
            list-style-type: none;
            margin: 0;
            padding: 0;
        }

        .li-item-nav {
            color: white;
            cursor: pointer; 
            padding: 20px 30px 20px 30px;
        }

        .li-item-nav:first-child {
            cursor: default;
        }
        .li-item-nav:first-child:hover {
            background-color: #555555;
        }
        
        .li-item-nav:hover {
            background-color: #04aa6d;
        }

        .mainInfoContainer {
            margin-top: 20px;
        }

        .dropbtn {
            background-color: transparent;
            color: white;
            font-size: 16px;
            border: none;
        }

        .dropdown {
            position: relative;
            display: inline-block;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            background-color: #f1f1f1;
            min-width: 160px;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
            z-index: 1;
        }

        .dropdown-content div {
            color: black;
            padding: 12px 16px;
            text-decoration: none;
            display: block;
        }
        
        pre {
            margin: 10px 50px;
            padding: 10px;
            border: 1px solid black;
            font-size: 16px;
        }
        
        .pCode{
            margin-left: 50px;
            font-size: 20px;
        }
        
        .pHead{
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 24px;
        }

        .dropdown-content div:hover {background-color: #ddd;}

        .dropdown:hover .dropdown-content {display: block;}

        .dropdown:hover .dropbtn {background-color: transparent;}

        .reference-list {
            counter-reset: item;
            margin: 10px 150px
        }
        .reference {
            margin-bottom: 25px;
            padding-left: 30px;
            text-indent: -30px;
            text-align: justify;
        }
        .reference:before {
            content: counter(item) ".";
            counter-increment: item;
            padding-right: 10px;
            color: #2c5282;
            font-weight: bold;
        }
        .author {
            font-weight: bold;
        }
        .title {
            font-style: italic;
        }
        .publisher {
            font-style: normal;
        }
        .electronic {
            color: #2b6cb0;
        }
        .url {
            word-break: break-all;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #4a5568;
        }
        .translation {
            font-size: 0.9em;
            color: #4a5568;
        }

        .main-container {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            max-width: 800px;
            margin: 0 auto;
            padding: 30px;
            color: #555555;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
        }
        .section-title {
            color: #555555;
            border-bottom: 2px solid #04aa6d;
            padding-bottom: 10px;
            margin-top: 30px;
            font-weight: 600;
        }
        .subsection-title {
            color: #04aa6d;
            margin-top: 25px;
            margin-bottom: 15px;
            font-weight: 500;
        }
        .command-list {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }
        .command-item {
            margin-bottom: 12px;
            padding: 12px 15px;
            background-color: white;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            transition: all 0.3s ease;
            border-left: 4px solid #04aa6d;
        }
        .command-item:hover {
            transform: translateX(5px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .command {
            color: #04aa6d;
            font-weight: bold;
            font-family: Consolas, monospace;
            padding: 2px 5px;
            background-color: #f0f0f0;
            border-radius: 3px;
        }

        .about-container {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            max-width: 800px;
            margin: 0 auto;
            padding: 30px;
            color: #555555;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
        }
        .about-title {
            color: #555555;
            border-bottom: 2px solid #04aa6d;
            padding-bottom: 10px;
            margin-top: 0;
            font-weight: 600;
        }
        .about-text {
            margin-bottom: 12px;
            padding: 0;
        }
        .about-highlight {
            color: #04aa6d;
            font-weight: bold;
            padding: 2px 4px;
            border-radius: 3px;
            background-color: #f0f0f0;
        }

        .grammar-container {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 30px;
            color: #555555;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
        }

        .grammar-title {
            color: #555555;
            border-bottom: 2px solid #04aa6d;
            padding-bottom: 10px;
            margin-top: 0;
            font-weight: 600;
        }

        .grammar-description {
            margin-bottom: 20px;
            line-height: 1.6;
        }

        .production-rule {
            font-family: Consolas, monospace;
            padding: 8px 15px;
            margin-bottom: 8px;
            background-color: #f9f9f9;
            border-left: 4px solid #04aa6d;
            border-radius: 4px;
        }

        .terminal {
            color: #04aa6d;
            font-weight: bold;
        }

        .non-terminal {
            color: #2c3e50;
            font-weight: 500;
        }

        .grammar-definition {
            margin-top: 25px;
            padding-top: 15px;
            border-top: 1px dashed #ddd;
        }

        .definition-text {
            margin-bottom: 15px;
        }

        .definition-list {
            padding-left: 20px;
        }

        .definition-term {
            margin-bottom: 8px;
            font-family: Consolas, monospace;
        }

        .grammar-type {
            font-weight: 600;
            color: #04aa6d;
        }

        .document-container {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 30px;
            color: #333;
            line-height: 1.6;
        }

        .document-title {
            color: #2c3e50;
            border-bottom: 2px solid #04aa6d;
            padding-bottom: 10px;
            margin-top: 0;
        }

        .document-description {
            font-size: 1.1em;
            color: #555;
            margin-bottom: 30px;
        }

        .section-title {
            color: #2980b9;
            margin-top: 30px;
            margin-bottom: 15px;
        }

        .section-text {
            margin-bottom: 20px;
        }

        .code-inline {
            font-family: Consolas, monospace;
            color: #d63384;
            background-color: #f8f9fa;
            padding: 2px 5px;
            border-radius: 3px;
        }

        .code-block {
            background-color: #f8f9fa;
            border-left: 4px solid #04aa6d;
            padding: 15px;
            margin: 20px 0;
            border-radius: 0 4px 4px 0;
            overflow-x: auto;
        }

        .code-block pre {
            margin: 0;
            font-family: Consolas, monospace;
            color: #333;
        }

        .examples-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 20px 0;
        }

        .example-item {
            font-family: Consolas, monospace;
            padding: 10px 15px;
            background-color: #f8f9fa;
            border-left: 3px solid #6f42c1;
            border-radius: 3px;
        }

        .test-cases {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 25px;
            background-color: #f8f9fa;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .test-cases-title {
            color: #2c3e50;
            border-bottom: 2px solid #04aa6d;
            padding-bottom: 10px;
            margin-top: 0;
        }

        .test-case {
            margin: 20px 0;
        }

        .case-title {
            color: #04aa6d;
            margin-bottom: 10px;
        }

        .input-code {
            font-family: Consolas, monospace;
            background-color: #f0f0f0;
            padding: 10px 15px;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        .output-errors {
            background-color: #fff;
            padding: 15px;
            border-radius: 4px;
            border-left: 3px solid #e74c3c;
        }

        .error-message {
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px dashed #eee;
        }

        .error-location {
            color: #555;
            font-weight: 500;
            display: inline-block;
            min-width: 150px;
        }

        .error-suggestion {
            color: #04aa6d;
            font-style: italic;
        }

        .case-divider {
            height: 1px;
            background-color: #ddd;
            margin: 25px 0;
        }

        .grammar-analysis {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 25px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .analysis-title {
            color: #2c3e50;
            border-bottom: 2px solid #04aa6d;
            padding-bottom: 10px;
            margin-top: 0;
            font-size: 1.5em;
        }

        .analysis-description {
            line-height: 1.6;
            color: #555;
            margin-bottom: 15px;
        }

        .math-notation {
            font-family: 'Consolas', monospace;
            color: #9b59b6;
            font-weight: 500;
        }

        .grammar-type {
            color: #04aa6d;
            font-weight: 600;
        }

        .graph-wrapper {
            margin: 25px 0;
            border: 1px solid #eee;
            border-radius: 6px;
            padding: 15px;
            background-color: #f8f9fa;
        }

        .graph-image {
            text-align: center;
            margin-bottom: 20px;
        }

        .graph-image img {
            max-width: 100%;
            height: auto;
        }

        .graph-legend {
            background-color: white;
            padding: 15px;
            border-radius: 4px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .line-style {
            width: 40px;
            height: 2px;
            margin-right: 10px;
        }

        .solid {
            background-color: #04aa6d;
        }

        .dashed {
            background: repeating-linear-gradient(to right, #e74c3c, #e74c3c 3px, transparent 3px, transparent 6px);
        }

        .legend-label {
            font-size: 0.9em;
            color: #555;
        }

        .analysis-summary {
            font-style: italic;
            color: #2980b9;
            text-align: center;
            margin-top: 20px;
        }
        .diagnostics-container {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
            color: #333;
        }

        .diagnostics-title {
            font-weight: bold;
            font-size: 1.2em;
            margin-bottom: 15px;
            color: #2c3e50;
        }

        .recursive-descent,
        .error-handling,
        .correction-methods,
        .implementation-details,
        .production-example,
        .recursive-example {
            margin-bottom: 15px;
        }

        .production-rule {
            font-family: Consolas, monospace;
            padding: 8px 12px;
            margin: 10px 0;
            background-color: #f5f5f5;
            border-left: 3px solid #04aa6d;
        }

        .non-terminal {
            color: #2980b9;
            font-weight: 600;
        }

        .terminal {
            color: #e74c3c;
            font-weight: 500;
        }

        .method-image {
            max-width: 100%;
            margin: 15px 0;
            border: 1px solid #ddd;
        }

        .correction-list {
            margin-left: 20px;
            padding-left: 15px;
        }

        .correction-list li {
            margin-bottom: 8px;
        }
    </style>
</head>
<body>
<main>
    <nav class="nav">
        <ul class="ul-nav">
            <li class="li-item-nav">ToFLaC Справка</li>
            <li class="li-item-nav dropdown">
                <button class="dropbtn">Текст</button>
                <div class="dropdown-content">
                    <div onclick="checkMe('task')">Постановка задачи</div>
                    <div onclick="checkMe('grammar')">Грамматика</div>
                    <div onclick="checkMe('homsk')">Классификация грамматики</div>
                    <div onclick="checkMe('analysis')">Метод анализа</div>
                    <div onclick="checkMe('diagnosis')">Диагностика и нейтрализация ошибок</div>
                    <div onclick="checkMe('test')">Тестовый пример</div>
                    <div onclick="checkMe('literature')">Список литературы</div>
                    <div onclick="checkMe('codeProgram')">Исходный код программы</div>
                </div>
            </li>
            <li class="li-item-nav dropdown">
                <button class="dropbtn">Справка</button>
                <div class="dropdown-content">
                    <div onclick="checkMe('instruments')">Инструменты</div>
                    <div onclick="checkMe('aboutProgram')">О программе</div>
                </div>
            </li>
        </ul>
    </nav>
    <div class="mainInfoContainer">

    </div>
</main>
<script>
    function checkMe(type) {
        const container = document.querySelector(".mainInfoContainer");
        container.innerHTML = '';
        switch (type) {
            case "codeProgram":
                container.innerHTML +=
                    `<div style="display: flex; flex-direction: column">
                        <p class="pHead">Исходный код программы</p>
                        <div>
                            <p class="pCode">TokenType.cs</p>
                            <code>
                            <pre>
namespace ToFLac_NEW.Model.Lexer
{
    public enum TokenType
    {
        Int = 1,
        Float = 2,
        Double = 3,
        Char = 4,
        Pointer = 5,
        Space = 6,
        Identifier = 7,
        Equal = 8,
        New = 9,
        LeftBracket = 10,
        RightBracket = 11,
        Semicolon = 12,
        BrokenInt = 13,
        BrokenFloat = 14,
        BrokenDouble = 15,
        BrokenChar = 16,
        BrokenNew = 17,
        BrokenIdentifier = 18,
        Invalid = 19
    }
}
                            </pre>
                            </code>
                        </div>
                        <div>
                            <p class="pCode">Token.cs</p>
                            <code>
                            <pre>
using System.Text.RegularExpressions;

namespace ToFLac_NEW.Model.Lexer
{
    public class Token
    {
        public static Dictionary<string, (string token, TokenType tokenType)> tokens = new()
        {
            { @"^int$", ("INT", TokenType.Int) },
            { @"^float$", ("FLOAT", TokenType.Float) },
            { @"^double$", ("DOUBLE", TokenType.Double) },
            { @"^char$", ("CHAR", TokenType.Char) },
            { @"^new$", ("NEW", TokenType.New) },
            { @"\*", ("POINTER", TokenType.Pointer) },
            { @"^ $", ("SPACE", TokenType.Space) },
            { @"^[a-zA-Z][a-zA-Z0-9]*$", ("IDENTIFIER", TokenType.Identifier) },
            { @"^=$", ("EQUAL", TokenType.Equal) },
            { @"^\($", ("LEFT_BRACKET", TokenType.LeftBracket) },
            { @"^\)$", ("RIGHT_BRACKET", TokenType.RightBracket) },
            { @"^;$", ("SEMICOLON", TokenType.Semicolon) },

            { @"^i[^n\w\s]?n[^t\w\s]?t$|^i[^n\w\s]?nt$|^in[^t\w\s]?t$|^i[^n\w\s]?n[^t\w\s]?t$", ("BROKEN_INT", TokenType.BrokenInt) },
            { @"^f[^l\w\s]?l[^o\w\s]?o[^a\w\s]?a[^t\w\s]?t$|^f[^l\w\s]?loat$|^fl[^o\w\s]?oat$|^flo[^a\w\s]?at$|^floa[^t\w\s]?t$|^f[^l\w\s]?l[^o\w\s]?o[^a\w\s]?a[^t\w\s]?t$", ("BROKEN_FLOAT", TokenType.BrokenFloat) },
            { @"^d[^o\w\s]?o[^u\w\s]?u[^b\w\s]?b[^l\w\s]?l[^e\w\s]?e$|^d[^o\w\s]?ouble$|^do[^u\w\s]?uble$|^dou[^b\w\s]?ble$|^doub[^l\w\s]?le$|^doubl[^e\w\s]?e$|^d[^o\w\s]?o[^u\w\s]?u[^b\w\s]?b[^l\w\s]?l[^e\w\s]?e$", ("BROKEN_DOUBLE", TokenType.BrokenDouble) },
            { @"^c[^h\w\s]?h[^a\w\s]?a[^r\w\s]?r$|^c[^h\w\s]?har$|^ch[^a\w\s]?ar$|^cha[^r\w\s]?r$|^c[^h\w\s]?h[^a\w\s]?a[^r\w\s]?r$", ("BROKEN_CHAR", TokenType.BrokenChar) },
            { @"^n[^e\w\s]?e[^w\w\s]?w$|^n[^e\w\s]?ew$|^ne[^w\w\s]?w$|^n[^e\w\s]?e[^w\w\s]?w$", ("BROKEN_NEW", TokenType.BrokenNew) },
            { @"^[^\s]$", ("INVALID", TokenType.Invalid) }
        };

        public int Line { get; set; }
        public int StartIdx { get; set; }
        public int EndIdx { get; set; }
        public string Message { get; set; }
        public string Terminal { get; set; }
        public string NonTerminal { get; set; }
        public TokenType TypeCode { get; set; }

        public Token(int line, int startIndex, int endIndex, string message, string terminal)
        {
            Line = line;
            StartIdx = startIndex;
            EndIdx = endIndex;
            Message = message;
            Terminal = terminal;
            var parsed = ParseToken(terminal);
            NonTerminal = parsed.Item1;
            TypeCode = parsed.Item2;
        }

        private (string, TokenType) ParseToken(string token)
        {
            foreach (var tokenReg in tokens)
            {
                if (Regex.IsMatch(token, tokenReg.Key))
                    return tokenReg.Value;
            }
            return ("INVALID", TokenType.Invalid);
        }

        public static Token MergeTokens(List<Token> tokens, int startIndex, int endIndex)
        {
            string mergedTerminal = string.Join("", tokens.Skip(startIndex).Take(endIndex - startIndex + 1).Select(t => t.Terminal));
            int mergedStartIdx = tokens[startIndex].StartIdx;
            int mergedEndIdx = tokens[endIndex].EndIdx;
            int mergedLine = tokens[startIndex].Line;

            return new Token(mergedLine, mergedStartIdx, mergedEndIdx, $"Сломанный идентификатор: '{mergedTerminal}'", mergedTerminal)
            {
                NonTerminal = "BROKEN_IDENTIFIER",
                TypeCode = TokenType.BrokenIdentifier
            };
        }
    }
}
                            </pre>
                            </code>
                        </div>
                        <div>
                            <p class="pCode">Lexer.cs</p>
                            <code>
                            <pre>
using System.Text.RegularExpressions;

namespace ToFLac_NEW.Model.Lexer
{
    public class Lexer
    {
        private const string pattern =
            @"(int|i[^n\w\s]?nt|in[^t\w\s]?t|i[^n\w\s]?n[^t\w\s]?t)|" +
            @"(float|f[^l\w\s]?loat|fl[^o\w\s]?oat|flo[^a\w\s]?at|floa[^t\w\s]?t|f[^l\w\s]?l[^o\w\s]?o[^a\w\s]?a[^t\w\s]?t)|" +
            @"(double|d[^o\w\s]?ouble|do[^u\w\s]?uble|dou[^b\w\s]?ble|doub[^l\w\s]?le|doubl[^e\w\s]?e|d[^o\w\s]?o[^u\w\s]?u[^b\w\s]?b[^l\w\s]?l[^e\w\s]?e)|" +
            @"(char|c[^h\w\s]?har|ch[^a\w\s]?ar|cha[^r\w\s]?r|c[^h\w\s]?h[^a\w\s]?a[^r\w\s]?r)|" +
            @"(new|n[^e\w\s]?ew|ne[^w\w\s]?w|n[^e\w\s]?e[^w\w\s]?w)|" +
            @"\*|" +
            @"=|\(|\)|;|" +
            @"[a-zA-Z][a-zA-Z0-9]*|" +
            @"\s+|" +
            @"[^\s]";

        public List<Token> GetLexemes(string text)
        {
            List<Token> tokens = new();
            string[] lines = text.Split('\n');

            for (int lineNum = 0; lineNum < lines.Length; lineNum++)
            {
                string line = lines[lineNum];
                int pos = 0;

                while (pos < line.Length)
                {
                    Match match = Regex.Match(line.Substring(pos), @"^(" + pattern + ")");
                    if (!match.Success)
                    {
                        tokens.Add(new Token(
                            lineNum + 1,
                            pos,
                            pos + 1,
                            $"Недопустимый символ: '{line[pos]}'",
                            line[pos].ToString()
                        ));
                        pos++;
                        continue;
                    }

                    string value = match.Value;
                    int start = pos;
                    pos += value.Length;

                    if (Regex.IsMatch(value, @"^int$|^float$|^double$|^char$"))
                    {
                        tokens.Add(new Token(
                            lineNum + 1,
                            start,
                            pos,
                            $"Тип: '{value}'",
                            value
                        ));
                    }
                    else if (Regex.IsMatch(value, @"^new$"))
                    {
                        tokens.Add(new Token(
                            lineNum + 1,
                            start,
                            pos,
                            $"Ключевое слово: '{value}'",
                            value
                        ));
                    }
                    else if (Regex.IsMatch(value, @"^\*$"))
                    {
                        tokens.Add(new Token(
                            lineNum + 1,
                            start,
                            pos,
                            $"Указатель: '{value}'",
                            value
                        ));
                    }
                    else if (Regex.IsMatch(value, @"^=$"))
                    {
                        tokens.Add(new Token(
                            lineNum + 1,
                            start,
                            pos,
                            $"Знак равенства: '{value}'",
                            value
                        ));
                    }
                    else if (Regex.IsMatch(value, @"^\($"))
                    {
                        tokens.Add(new Token(
                            lineNum + 1,
                            start,
                            pos,
                            $"Открывающая скобка: '{value}'",
                            value
                        ));
                    }
                    else if (Regex.IsMatch(value, @"^\)$"))
                    {
                        tokens.Add(new Token(
                            lineNum + 1,
                            start,
                            pos,
                            $"Закрывающая скобка: '{value}'",
                            value
                        ));
                    }
                    else if (Regex.IsMatch(value, @"^;$"))
                    {
                        tokens.Add(new Token(
                            lineNum + 1,
                            start,
                            pos,
                            $"Точка с запятой: '{value}'",
                            value
                        ));
                    }
                    else if (Regex.IsMatch(value, @"^\s+$"))
                    {
                        tokens.Add(new Token(
                            lineNum + 1,
                            start,
                            pos,
                            $"Пробел: '{value}'",
                            value
                        ));
                    }
                    else if (Regex.IsMatch(value, @"^[a-zA-Z][a-zA-Z0-9]*$"))
                    {
                        tokens.Add(new Token(
                            lineNum + 1,
                            start,
                            pos,
                            $"Идентификатор: '{value}'",
                            value
                        ));
                    }
                    else if (Regex.IsMatch(value, @"^i[^n\w\s]?nt$|^in[^t\w\s]?t$|^i[^n\w\s]?n[^t\w\s]?t$"))
                    {
                        tokens.Add(new Token(
                            lineNum + 1,
                            start,
                            pos,
                            $"Сломанный int: '{value}'",
                            value
                        ));
                    }
                    else if (Regex.IsMatch(value, @"^f[^l\w\s]?loat$|^fl[^o\w\s]?oat$|^flo[^a\w\s]?at$|^floa[^t\w\s]?t$|^f[^l\w\s]?l[^o\w\s]?o[^a\w\s]?a[^t\w\s]?t$"))
                    {
                        tokens.Add(new Token(
                            lineNum + 1,
                            start,
                            pos,
                            $"Сломанный float: '{value}'",
                            value
                        ));
                    }
                    else if (Regex.IsMatch(value, @"^d[^o\w\s]?ouble$|^do[^u\w\s]?uble$|^dou[^b\w\s]?ble$|^doub[^l\w\s]?le$|^doubl[^e\w\s]?e$|^d[^o\w\s]?o[^u\w\s]?u[^b\w\s]?b[^l\w\s]?l[^e\w\s]?e$"))
                    {
                        tokens.Add(new Token(
                            lineNum + 1,
                            start,
                            pos,
                            $"Сломанный double: '{value}'",
                            value
                        ));
                    }
                    else if (Regex.IsMatch(value, @"^c[^h\w\s]?har$|^ch[^a\w\s]?ar$|^cha[^r\w\s]?r$|^c[^h\w\s]?h[^a\w\s]?a[^r\w\s]?r$"))
                    {
                        tokens.Add(new Token(
                            lineNum + 1,
                            start,
                            pos,
                            $"Сломанный char: '{value}'",
                            value
                        ));
                    }
                    else if (Regex.IsMatch(value, @"^n[^e\w\s]?ew$|^ne[^w\w\s]?w$|^n[^e\w\s]?e[^w\w\s]?w$"))
                    {
                        tokens.Add(new Token(
                            lineNum + 1,
                            start,
                            pos,
                            $"Сломанный new: '{value}'",
                            value
                        ));
                    }
                    else
                    {
                        tokens.Add(new Token(
                            lineNum + 1,
                            start,
                            pos,
                            $"Недопустимый токен: '{value}'",
                            value
                        ));
                    }
                }
            }

            return MergeBrokenIdentifiers(tokens);
        }

        private List<Token> MergeBrokenIdentifiers(List<Token> tokens)
        {
            List<Token> mergedTokens = new();
            int i = 0;

            while (i < tokens.Count)
            {
                if (tokens[i].TypeCode == TokenType.Identifier)
                {
                    int startIndex = i;
                    int endIndex = i;

                    if (endIndex + 2 < tokens.Count &&
                        tokens[endIndex + 1].TypeCode == TokenType.Invalid &&
                        tokens[endIndex + 2].TypeCode == TokenType.Identifier)
                    {
                        endIndex += 2;

                        Token mergedToken = Token.MergeTokens(tokens, startIndex, endIndex);
                        mergedTokens.Add(mergedToken);
                        i = endIndex + 1;

                        if (i < tokens.Count && tokens[i].TypeCode == TokenType.Invalid)
                        {
                            mergedTokens.Add(tokens[i]);
                            i++;
                        }
                    }
                    else
                    {
                        mergedTokens.Add(tokens[i]);
                        i++;
                    }
                }
                else
                {
                    mergedTokens.Add(tokens[i]);
                    i++;
                }
            }

            return mergedTokens;
        }
    }
}
                            </pre>
                            </code>
                        </div>
                        <div>
                            <p class="pCode">Lexeme.cs</p>
                            <code>
                            <pre>
namespace ToFLac_NEW.Model.Lexer
{
    public static class Lexeme
    {
        public static Dictionary<string, TokenType> Lexemes = new Dictionary<string, TokenType>
        {
            { "*", TokenType.Pointer },
            { "new", TokenType.New },
            { "=", TokenType.Equal },
            { " ", TokenType.Space },
            { ";", TokenType.Semicolon },
            { "(", TokenType.LeftBracket },
            { ")", TokenType.RightBracket }
        };

        public static string GetLexeme(TokenType lexeme)
        {
            foreach (var kvp in Lexemes)
            {
                if (kvp.Value == lexeme)
                    return kvp.Key;
            }

            return " ";
        }
    }
}
                            </pre>
                            </code>
                        </div>
                        <div>
                            <p class="pCode">ErrorType.cs</p>
                            <code>
                            <pre>
namespace ToFLac_NEW.Model.Parser
{
    public enum ErrorType
    {
        PUSH,
        REPLACE,
        DELETE
    }
}
                            </pre>
                            </code>
                        </div>
                        <div>
                            <p class="pCode">ErrorToken.cs</p>
                            <code>
                            <pre>
namespace ToFLac_NEW.Model.Parser
{
    public class ErrorToken
    {
        public int Line { get; set; }
        public int Index { get; set; }
        public string Message { get; set; }
        public ErrorType ErrorType { get; set; }

        public ErrorToken(int line, int index, string message, ErrorType errorType)
        {
            Line = line;
            Index = index;
            Message = message;
            ErrorType = errorType;
        }
    }
}
                            </pre>
                            </code>
                        </div>
                        <div>
                            <p class="pCode">Parser.cs</p>
                            <code>
                            <pre>
using System.Text.RegularExpressions;
using ToFLac_NEW.Model.Lexer;

namespace ToFLac_NEW.Model.Parser
{
    public class Parser
    {
        private readonly List<ErrorToken> _errors = new();
        private List<List<Token>> _tokens = new();

        public List<ErrorToken> Parse(List<Token> inputTokens)
        {
            _errors.Clear();
            _tokens.Clear();

            GroupTokensByLine(inputTokens);

            foreach (var lineTokens in _tokens)
            {
                var lineParser = new LineTokenRecursiveParser(lineTokens);
                _errors.AddRange(lineParser.Parse());
            }

            return _errors;
        }

        private void GroupTokensByLine(List<Token> tokens)
        {
            _tokens = tokens
                .GroupBy(token => token.Line)
                .Select(group => group.ToList())
                .ToList();
        }
    }

    public partial class LineTokenRecursiveParser
    {
        private readonly List<Token> _tokens;

        public LineTokenRecursiveParser(List<Token> tokens)
        {
            _tokens = tokens ?? throw new ArgumentNullException(nameof(tokens));
        }

        public List<ErrorToken> Parse()
        {
            int currentPosition = 0;
            List<ErrorToken> errors = new();
            return ParseStart(currentPosition, errors);
        }

        private List<ErrorToken> ParseStart(int currentPosition,  List<ErrorToken> errors)
        {
            if (currentPosition >= _tokens.Count)
                return errors;

            currentPosition = SkipInvalidTokens(currentPosition, errors);

            if (_tokens[currentPosition].TypeCode == TokenType.Space)
                return ParseStart(currentPosition + 1, errors);

            var currentType = _tokens[currentPosition].TypeCode;

            if (currentType == TokenType.BrokenInt ||
                currentType == TokenType.BrokenFloat ||
                currentType == TokenType.BrokenDouble ||
                currentType == TokenType.BrokenChar)
            {
                AddBrokenErrors(currentPosition, errors);
                return ParsePointer(currentPosition + 1, errors);
            }

            if (currentType == TokenType.Int ||
                currentType == TokenType.Float ||
                currentType == TokenType.Double ||
                currentType == TokenType.Char)
                return ParsePointer(currentPosition + 1, errors);

            return GetMinErrors(
                ParsePointer(currentPosition, CreateErrorListWithType(currentPosition, ErrorType.PUSH, errors, _tokens[currentPosition].Line)),
                ParsePointer(currentPosition + 1, CreateErrorListWithType(currentPosition, ErrorType.REPLACE, errors, _tokens[currentPosition].Line)),
                ParseStart(currentPosition + 1, CreateErrorListWithType(currentPosition, ErrorType.DELETE, errors, _tokens[currentPosition].Line))
            );
        }

        private List<ErrorToken> ParsePointer(int currentPosition, List<ErrorToken> errors)
        {
            if (currentPosition >= _tokens.Count)
                return errors;

            currentPosition = SkipInvalidTokens(currentPosition, errors);

            if (_tokens[currentPosition].TypeCode == TokenType.Space)
                return ParsePointer(currentPosition + 1, errors);

            if (_tokens[currentPosition].TypeCode == TokenType.BrokenIdentifier ||
                _tokens[currentPosition].TypeCode == TokenType.Identifier)
            {
                errors.Add(new ErrorToken(
                    _tokens[currentPosition].Line,
                    currentPosition,
                    "Вставить лексему: '*'",
                    ErrorType.PUSH)
                );

                return ParseIdentifier(currentPosition, errors);
            }

            if (_tokens[currentPosition].TypeCode != TokenType.Pointer)
            {
                return GetMinErrors(
                    ParseIdentifier(currentPosition + 1, CreateErrorList(currentPosition, TokenType.Pointer, ErrorType.REPLACE, errors, _tokens[currentPosition].Line)),
                    ParseIdentifier(currentPosition, CreateErrorList(currentPosition, TokenType.Pointer, ErrorType.PUSH, errors, _tokens[currentPosition].Line)),
                    ParsePointer(currentPosition + 1, CreateErrorList(currentPosition, TokenType.Pointer, ErrorType.DELETE, errors, _tokens[currentPosition].Line))
                );
            }

            return ParseIdentifier(currentPosition + 1, errors);
        }

        private List<ErrorToken> ParseIdentifier(int currentPosition, List<ErrorToken> errors)
        {
            if (currentPosition >= _tokens.Count)
                return errors;

            currentPosition = SkipInvalidTokens(currentPosition, errors);

            if (_tokens[currentPosition].TypeCode == TokenType.Space)
                return ParseIdentifier(currentPosition + 1, errors);

            if (_tokens[currentPosition].TypeCode == TokenType.BrokenIdentifier)
            {
                AddBrokenErrors(currentPosition, errors);
                return ParseEqual(currentPosition + 1, errors);
            }

            if (_tokens[currentPosition].TypeCode != TokenType.Identifier)
            {
                return GetMinErrors(
                    ParseEqual(currentPosition, CreateErrorList(currentPosition, TokenType.Identifier, ErrorType.PUSH, errors, _tokens[currentPosition].Line)),
                    ParseEqual(currentPosition + 1, CreateErrorList(currentPosition, TokenType.Identifier, ErrorType.REPLACE, errors, _tokens[currentPosition].Line)),
                    ParseIdentifier(currentPosition + 1, CreateErrorList(currentPosition, TokenType.Identifier, ErrorType.DELETE, errors, _tokens[currentPosition].Line))
                );
            }

            return ParseEqual(currentPosition + 1, errors);
        }

        private List<ErrorToken> ParseEqual(int currentPosition, List<ErrorToken> errors)
        {
            if (currentPosition >= _tokens.Count)
                return errors;

            currentPosition = SkipInvalidTokens(currentPosition, errors);

            if (_tokens[currentPosition].TypeCode == TokenType.Space)
                return ParseEqual(currentPosition + 1, errors);

            if (_tokens[currentPosition].TypeCode == TokenType.BrokenNew ||
                _tokens[currentPosition].TypeCode == TokenType.New)
            {
                errors.Add(new ErrorToken(
                    _tokens[currentPosition].Line,
                    currentPosition,
                    "Вставить лексему: '='",
                    ErrorType.PUSH)
                );

                return ParseNew(currentPosition, errors);
            }

            if (_tokens[currentPosition].TypeCode != TokenType.Equal)
            {
                return GetMinErrors(
                    ParseNew(currentPosition, CreateErrorList(currentPosition, TokenType.Equal, ErrorType.PUSH, errors, _tokens[currentPosition].Line)),
                    ParseNew(currentPosition + 1, CreateErrorList(currentPosition, TokenType.Equal, ErrorType.REPLACE, errors, _tokens[currentPosition].Line)),
                    ParseEqual(currentPosition + 1, CreateErrorList(currentPosition, TokenType.Equal, ErrorType.DELETE, errors, _tokens[currentPosition].Line))
                );
            }

            return ParseNew(currentPosition + 1, errors);
        }

        private List<ErrorToken> ParseNew(int currentPosition, List<ErrorToken> errors)
        {
            if (currentPosition >= _tokens.Count)
                return errors;

            currentPosition = SkipInvalidTokens(currentPosition, errors);

            if (_tokens[currentPosition].TypeCode == TokenType.Space)
                return ParseNew(currentPosition + 1, errors);

            if (_tokens[currentPosition].TypeCode == TokenType.BrokenNew)
            {
                AddBrokenErrors(currentPosition, errors);
                return ParseSpaceAfterNew(currentPosition + 1, errors);
            }

            if (_tokens[currentPosition].TypeCode != TokenType.New)
            {
                return GetMinErrors(
                    ParseSpaceAfterNew(currentPosition, CreateErrorList(currentPosition, TokenType.New, ErrorType.PUSH, errors, _tokens[currentPosition].Line)),
                    ParseSpaceAfterNew(currentPosition + 1, CreateErrorList(currentPosition, TokenType.New, ErrorType.REPLACE, errors, _tokens[currentPosition].Line)),
                    ParseNew(currentPosition + 1, CreateErrorList(currentPosition, TokenType.New, ErrorType.DELETE, errors, _tokens[currentPosition].Line))
                );
            }

            return ParseSpaceAfterNew(currentPosition + 1, errors);
        }

        private List<ErrorToken> ParseSpaceAfterNew(int currentPosition, List<ErrorToken> errors)
        {
            if (currentPosition >= _tokens.Count)
                return errors;

            if (_tokens[currentPosition].TypeCode != TokenType.Space)
            {
                return GetMinErrors(
                    ParseType(currentPosition, CreateErrorList(currentPosition, TokenType.Space, ErrorType.PUSH, errors, _tokens[currentPosition].Line)),
                    ParseType(currentPosition + 1, CreateErrorList(currentPosition, TokenType.Space, ErrorType.REPLACE, errors, _tokens[currentPosition].Line)),
                    ParseSpaceAfterNew(currentPosition + 1, CreateErrorList(currentPosition, TokenType.Space, ErrorType.DELETE, errors, _tokens[currentPosition].Line))
                );
            }

            return ParseType(currentPosition + 1, errors);
        }

        private List<ErrorToken> ParseType(int currentPosition, List<ErrorToken> errors)
        {
            if (currentPosition >= _tokens.Count)
                return errors;

            currentPosition = SkipInvalidTokens(currentPosition, errors);

            if (_tokens[currentPosition].TypeCode == TokenType.Space)
                return ParseType(currentPosition + 1, errors);

            var currentType = _tokens[currentPosition].TypeCode;

            if (currentType == TokenType.BrokenInt ||
                currentType == TokenType.BrokenFloat ||
                currentType == TokenType.BrokenDouble ||
                currentType == TokenType.BrokenChar)
            {
                AddBrokenErrors(currentPosition, errors);
                return ParseLeftBracket(currentPosition + 1, errors);
            }

            if (currentType == TokenType.Int ||
                currentType == TokenType.Float ||
                currentType == TokenType.Double ||
                currentType == TokenType.Char)
                return ParseLeftBracket(currentPosition + 1, errors);

            return GetMinErrors(
                ParseLeftBracket(currentPosition, CreateErrorListWithType(currentPosition, ErrorType.PUSH, errors, _tokens[currentPosition].Line)),
                ParseLeftBracket(currentPosition + 1, CreateErrorListWithType(currentPosition, ErrorType.REPLACE, errors, _tokens[currentPosition].Line)),
                ParseType(currentPosition + 1, CreateErrorListWithType(currentPosition, ErrorType.DELETE, errors, _tokens[currentPosition].Line))
            );
        }

        private List<ErrorToken> ParseLeftBracket(int currentPosition, List<ErrorToken> errors)
        {
            if (currentPosition >= _tokens.Count)
                return errors;

            currentPosition = SkipInvalidTokens(currentPosition, errors);

            if (_tokens[currentPosition].TypeCode == TokenType.Space)
                return ParseLeftBracket(currentPosition + 1, errors);

            if (_tokens[currentPosition].TypeCode == TokenType.Semicolon)
            {
                errors.Add(new ErrorToken(
                    _tokens[currentPosition].Line,
                    currentPosition,
                    "Вставить лексему: '('",
                    ErrorType.PUSH)
                );

                errors.Add(new ErrorToken(
                    _tokens[currentPosition].Line,
                    currentPosition,
                    "Вставить лексему: ')'",
                    ErrorType.PUSH)
                );

                return ParseSemicolon(currentPosition, errors);
            }

            if (currentPosition + 1 < _tokens.Count &&
                _tokens[currentPosition].TypeCode == TokenType.LeftBracket &&
                _tokens[currentPosition + 1].TypeCode == TokenType.Semicolon)
            {
                errors.Add(new ErrorToken(
                    _tokens[currentPosition].Line,
                    currentPosition,
                    "Вставить лексему: ')'",
                    ErrorType.PUSH)
                );

                return ParseSemicolon(currentPosition + 1, errors);
            }

            if (_tokens[currentPosition].TypeCode != TokenType.LeftBracket)
            {
                return GetMinErrors(
                    ParseRightBracket(currentPosition, CreateErrorList(currentPosition, TokenType.LeftBracket, ErrorType.PUSH, errors, _tokens[currentPosition].Line)),
                    ParseRightBracket(currentPosition + 1, CreateErrorList(currentPosition, TokenType.LeftBracket, ErrorType.REPLACE, errors, _tokens[currentPosition].Line)),
                    ParseLeftBracket(currentPosition + 1, CreateErrorList(currentPosition, TokenType.LeftBracket, ErrorType.DELETE, errors, _tokens[currentPosition].Line))
                );
            }

            return ParseRightBracket(currentPosition + 1, errors);
        }

        private List<ErrorToken> ParseRightBracket(int currentPosition, List<ErrorToken> errors)
        {
            if (currentPosition >= _tokens.Count)
                return errors;

            currentPosition = SkipInvalidTokens(currentPosition, errors);

            if (_tokens[currentPosition].TypeCode == TokenType.Space)
                return ParseRightBracket(currentPosition + 1, errors);

            if (_tokens[currentPosition].TypeCode == TokenType.Semicolon)
            {
                errors.Add(new ErrorToken(
                    _tokens[currentPosition].Line,
                    currentPosition,
                    "Вставить лексему: ')'",
                    ErrorType.PUSH
                ));
                return ParseSemicolon(currentPosition, errors);
            }

                if (_tokens[currentPosition].TypeCode != TokenType.RightBracket)
            {
                return GetMinErrors(
                    ParseSemicolon(currentPosition, CreateErrorList(currentPosition, TokenType.RightBracket, ErrorType.PUSH, errors, _tokens[currentPosition].Line)),
                    ParseSemicolon(currentPosition + 1, CreateErrorList(currentPosition, TokenType.RightBracket, ErrorType.REPLACE, errors, _tokens[currentPosition].Line)),
                    ParseRightBracket(currentPosition + 1, CreateErrorList(currentPosition, TokenType.RightBracket, ErrorType.DELETE, errors, _tokens[currentPosition].Line))
                );
            }

            return ParseSemicolon(currentPosition + 1, errors);
        }

        private List<ErrorToken> ParseSemicolon(int currentPosition, List<ErrorToken> errors)
        {
            currentPosition = SkipInvalidTokens(currentPosition, errors);

            if (currentPosition >= _tokens.Count)
            {
                errors.Add(new ErrorToken(
                    _tokens.Last().Line,
                    _tokens.Last().StartIdx,
                    CreateErrorMessage(TokenType.Semicolon, ErrorType.PUSH, currentPosition),
                    ErrorType.PUSH
                ));
                return errors;
            }

            if (_tokens[currentPosition].TypeCode == TokenType.Space)
                return ParseSemicolon(currentPosition + 1, errors);

            if (_tokens[currentPosition].TypeCode != TokenType.Semicolon)
            {
                errors.Add(new ErrorToken(
                    _tokens[currentPosition].Line,
                    currentPosition,
                    CreateErrorMessage(TokenType.Semicolon, ErrorType.PUSH, currentPosition),
                    ErrorType.PUSH
                ));
            }

            return errors;
        }

        private int SkipInvalidTokens(int currentPosition, List<ErrorToken> errors)
        {
            while (currentPosition < _tokens.Count && _tokens[currentPosition].TypeCode == TokenType.Invalid)
            {
                errors.Add(new ErrorToken(
                    _tokens[currentPosition].Line,
                    currentPosition,
                    $"Удалить недопустимый символ: '{_tokens[currentPosition].Terminal}'",
                    ErrorType.DELETE
                ));

                currentPosition++;
            }

            return currentPosition;
        }

        private static List<ErrorToken> GetMinErrors(List<ErrorToken> push, List<ErrorToken> replace, List<ErrorToken> delete)
        {
            if (push.Count < replace.Count && push.Count < delete.Count)
            {
                return push;
            }

            return replace.Count < delete.Count ? replace : delete;
        }

        private List<ErrorToken> CreateErrorList(int currentPosition, TokenType type, ErrorType errorType, List<ErrorToken> currentErrors, int currentLine)
        {
            var newErrors = new List<ErrorToken>(currentErrors);

            newErrors.Add(new ErrorToken(
                currentLine,
                currentPosition,
                CreateErrorMessage(type, errorType, currentPosition),
                errorType
            ));

            return newErrors;
        }

        private List<ErrorToken> CreateErrorListWithType(int currentPosition, ErrorType errorType, List<ErrorToken> currentErrors, int currentLine)
        {
            var newErrors = new List<ErrorToken>(currentErrors);

            newErrors.Add(new ErrorToken(
                currentLine,
                currentPosition,
                CreateTypeErrorMessage(errorType, currentPosition),
                errorType
            ));

            return newErrors;
        }

        private string CreateErrorMessage(TokenType type, ErrorType errorType, int currentPosition)
        {
            string lexeme = type == TokenType.Identifier
                ? type.ToString()
                : Lexeme.GetLexeme(type);

            return errorType switch
            {
                ErrorType.PUSH => $"Вставить лексему: '{lexeme}'",
                ErrorType.REPLACE => $"Заменить лексему '{_tokens[currentPosition].Terminal}' на лексему '{lexeme}'",
                ErrorType.DELETE => $"Удалить недопустимый символ '{_tokens[currentPosition].Terminal}'",
                _ => string.Empty
            };
        }

        private string CreateTypeErrorMessage(ErrorType errorType, int currentPosition)
        {
            return errorType switch
            {
                ErrorType.PUSH => "Вставить лексему: 'int', 'float', 'double' или 'char'",
                ErrorType.REPLACE => $"Заменить лексему: '{_tokens[currentPosition].Terminal}' на лексему 'int', 'float', 'double' или 'char'",
                ErrorType.DELETE => $"Удалить недопустимый символ: '{_tokens[currentPosition].Terminal}'",
                _ => string.Empty
            };
        }

        public void AddBrokenErrors(int currentPosition, List<ErrorToken> errors)
        {
            string terminal = _tokens[currentPosition].Terminal;

            string validCharsPattern = @"^[a-zA-Z0-9]$";

            for (int i = 0; i < terminal.Length; i++)
            {
                string currentChar = terminal[i].ToString();
                if (!Regex.IsMatch(currentChar, validCharsPattern))
                {
                    errors.Add(new ErrorToken(
                        _tokens[currentPosition].Line,
                        currentPosition,
                        $"Удалить недопустимый символ '{currentChar}' в лексеме '{terminal}'",
                        ErrorType.DELETE
                    ));
                }
            }
        }
    }
}
                        </pre>
                        </code>
                        </div>
                    </div>`
                break
            case "literature":
                container.innerHTML +=
                    `<img src="../Resources/Images/HelpHtml/img7.png">`
                break;
            case "instruments":
                container.innerHTML +=
                    `<div class="main-container">
                        <h2 class="section-title">Основные команды редактора</h2>
                
                        <h3 class="subsection-title">Запуск:</h3>
                        <ul class="command-list">
                            <li class="command-item">Запуск анализа: <span class="command">Пуск</span></li>
                        </ul>
                
                        <h3 class="subsection-title">Файловые операции:</h3>
                        <ul class="command-list">
                            <li class="command-item">Создать файл: <span class="command">Файл ⇒ Создать</span></li>
                            <li class="command-item">Открыть файл: <span class="command">Файл ⇒ Открыть</span></li>
                            <li class="command-item">Сохранить файл: <span class="command">Файл ⇒ Сохранить</span></li>
                            <li class="command-item">Сохранить как: <span class="command">Файл ⇒ Сохранить как</span></li>
                        </ul>
                
                        <h3 class="subsection-title">Редактирование:</h3>
                        <ul class="command-list">
                            <li class="command-item">Отменить: <span class="command">Правка ⇒ Отменить</span></li>
                            <li class="command-item">Вернуть: <span class="command">Правка ⇒ Вернуть</span></li>
                            <li class="command-item">Копировать: <span class="command">Правка ⇒ Копировать</span></li>
                            <li class="command-item">Вырезать: <span class="command">Правка ⇒ Вырезать</span></li>
                            <li class="command-item">Вставить: <span class="command">Правка ⇒ Вставить</span></li>
                            <li class="command-item">Удалить всё: <span class="command">Правка ⇒ Удалить всё</span></li>
                        </ul>
                
                        <h3 class="subsection-title">Информация:</h3>
                        <ul class="command-list">
                            <li class="command-item">Постановка задачи: <span class="command">Текст ⇒ Постановка задачи</span></li>
                            <li class="command-item">Грамматика: <span class="command">Текст ⇒ Грамматика</span></li>
                            <li class="command-item">Классификация грамматики: <span class="command">Текст ⇒ Классификация грамматики</span></li>
                            <li class="command-item">Метод анализа: <span class="command">Текст ⇒ Метод анализа</span></li>
                            <li class="command-item">Диагностика и нейтрализация ошибок: <span class="command">Текст ⇒ Диагностика и нейтрализация ошибок</span></li>
                            <li class="command-item">Тестовый пример: <span class="command">Текст ⇒ Тестовый пример</span></li>
                            <li class="command-item">Список литературы: <span class="command">Текст ⇒ Список литературы</span></li>
                            <li class="command-item">Исходный код программы: <span class="command">Текст ⇒ Исходный код программы</span></li>
                        </ul>
                    </div>
                    `
                break;
            case "aboutProgram":
                container.innerHTML +=
                    `<div class="about-container">
                        <h1 class="about-title">Информация о программе</h1>
                        
                        <p class="about-text">Анализатор кода</p>
                        <p class="about-text">Версия <span class="about-highlight">1.0.0</span></p>
                        <p class="about-text">Курсовая работа по дисциплине <span class="about-highlight">'Теория формальных языков и компиляторов'</span></p>
                        <p class="about-text">Тема: <span class="about-highlight">Оператор new для создания объекта с инициализацией (вызов конструктора) на языке C++</span></p>
                        <p class="about-text">Выполнил:</p>
                        <p class="about-text">Студент:</p>
                        <p class="about-text"><span class="about-highlight">Хусаинов Артур Мансурович</span></p>
                        <p class="about-text">Создан с использованием <span class="about-highlight">C#, WPF</span></p>
                    </div>`
                break;
            case "grammar":
                container.innerHTML +=
                    `<img src="../Resources/Images/HelpHtml/img2.png">`
                break;
            case "homsk":
                container.innerHTML +=
                    `<img src="../Resources/Images/HelpHtml/img3.png">`
                break;
            case "task":
                container.innerHTML +=
                    `<img src="../Resources/Images/HelpHtml/img1.png">
`
                break;
            case "test":
                container.innerHTML += `
                <img src="../Resources/Images/HelpHtml/img6_1.png">
                <img src="../Resources/Images/HelpHtml/img6_2.png">
                <img src="../Resources/Images/HelpHtml/img6_3.png">
                `
                break;
            case "analysis":
                container.innerHTML += `
                <img src="../Resources/Images/HelpHtml/img4.png">
                `
                break;
            case "diagnosis":
                container.innerHTML +=
                    `
                    <img src="../Resources/Images/HelpHtml/img5.png">
                    `
                break;
        }
    }
</script>
</body>
</html>